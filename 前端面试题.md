1. ##### 什么是变量的提升

   JavaScript在函数内部声明的变量，都会提升到作用域的最顶上，函数声明有函数提升，

   变量提升只提升变量不提升变量值，提升的变量如果先使用它，它的值将会是undefined

   函数声明的优先级高于变量声明的优先级，函数提升会将函数声明和函数定义的部分一起被提升，函数表达式不会提升

2. ##### 什么是对象？什么是数组？

   在JavaScript中，几乎所有的事物都是对象，对象有其属性和方法

   数组其实是对象的实例化

3. ##### apply、call、bind的区别是什么？

   相似之处：

   1. 都是用来改变函数的this对象的指向
   2. 第一个参数都是this要指向的对象
   3. 都可以利用后续参数传参

   区别：

   1. call和apply都是对函数的直接调用，而bind方法返回的仍然是一个函数，因此后面还需（）来进行调用才行

   2. call后续参数传参是一个一个传，而apply传参是传一个数组，bind传参的方式和call相同，但是由于bind返回的仍然是一个函数，所以还可以在调用的时候再传参。

      https://www.cnblogs.com/cosiray/p/4512969.html

4. ##### 浏览器对象有哪些？

   window、screen、history、location、navigator、document

5. ##### 什么是懒加载？

   懒加载其实就是延时加载，即当对象需要用到的时候再去加载。

   涉及到图片，flash资源，iframe，网页编辑器等占用较大带宽，且这些模块暂且不在浏览器可视区，因此可以使用lazyload在适当的时候加载该类资源，避免网页打开时加载过多资源，让用户等待太久

6. ##### 什么是构造函数

   在 JavaScript 中，用 new 关键字来调用的函数，称为构造函数。构造函数首字母一般大写

7. ##### 数组的遍历有哪些方法

   forEach、map、reduce、filter、some、every、find、findIndex、reduceRight

8. ##### 什么是事件对象？

   Event对象代表事件的状态，如click，mousemove等

   https://www.cnblogs.com/websmile/p/8807334.html

9. ##### 什么是异步？什么是同步？

   同步任务是指在主线程上排队执行的任务，只有前一个任务执行完毕，才能继续执行下一个任务

   同步：等待异步代码执行完毕后才执行接下来的代码

   异步任务是指不进入主线程，而进入任务队列的任务，只有任务队列通知主线程，某个异步任务可以执行了，该任务才会进入主线程

   异步：不等待结果就执行接下来的代码

10. ##### 什么是宏管理？什么是微管理？

    宏任务（macrotask）和微任务（microtask）表示异步任务的两种分类。

    在挂起任务时，js引擎会将所有任务按照类别分到这两个队列中，首先在macrotask的队列（也叫task queue）中取出第一个任务，执行完毕后取出microtask队列中的所有任务顺序执行；之后再取macrotask任务，周而复始，直至两个队列的任务都取完

11. ##### 什么是原型

    - 每个对象都会在其内部初始化一个属性，就是prototype（原型），当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会又自己的prototype，于是就这样一直找下去，也就是我们平时所说的原型链的概念。
    - 关系：instance.constructor.prototype = instance.proto
    - 特点：JavaScript对象就是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。

12. ##### 数组去重

    ```
    function(array){
    	array.reduce((pre,cur) => {
    		if(!pre.includes(cur)){
    			pre.push(cur)
    		}
    		return pre;
    	},[])
    }
    
    function unique(arr){
    	return [...new Set(arr)]
    }
    ```

    

13. ##### 什么是数组塌陷？

    在对数组进行操作的时候，有些操作可能会使数组的长度发生变化，同时操作的数组那个项的下一个索引会被跳过，从而造成数组的某项会被跳过，这种叫做数组的塌陷现象。

14. ##### 哪些内置对象？

    数据封装类对象：Object、Array、Boolean、Number、String
    
    其他对象：Function、Arguments、Math、Date、RegExp、Error

17. ##### 一个等号、两个等号、三个等号有什么区别

    =：赋值，后面变量的值赋给前面的变量

    ==：当且仅当两个运算数相等时，它返回true，即不检查数据类型

    ===：除了检查值相等外，还需检查数据类型是否相等

18. ##### 正则的i是什么

    i: 不区分大小写

19. ##### 正则怎么获取两个字的方法

    ```
    var reg = /路遥/g
    var string = 'sss路遥kkk'
    var res = reg.exec(string)[0]
    ```

    

20. ##### 怎么用正则获取两个字全局的所有字

    ```
    var reg = /[路遥]/g
    var string = 'sss路遥kkk路遥0odf路adf遥'
    var arr = []
    for(let i = 0; i < string.length; i++){
    	arr.push(string.search(reg))
    }
    ```

    

21. ##### 什么是闭包？有什么特性、对页面有什么影响

    - 闭包是指有权访问另一个函数作用域中的变量的函数，创建你闭包常见方式，就是在一个函数的内部创建另一个函数
    - 使用闭包主要是为了设计私有的方法和变量，闭包的优点是可以避免变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄漏。在js中，函数即闭包，只有函数才会产生作用域的概念
    - 闭包有三个特性：
      1. 函数嵌套函数
      2. 函数内部可以引用外部的参数和变量
      3. 参数和变量不会被垃圾回收机制回收

22. ##### 写一个函数找出一个电话号码中有几个5

    ```
    function(number){
    	let count = 0;
    	for(let i = 0; i < number.length; i++){
    		number[i] === 5 && count++;
    	}
    	return count
    }
    ```

    

23. ##### 什么是ajax？

    ajax = 异步JavaScript和XML。

    ajax是一种用于创建快速动态网页的技术。

    通过在后台与服务器进行少量数据交换，AJAX可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。

24. ##### 什么是浏览器跨域？

    一个域名地址组成为http://（协议）www（子域名）.abc.com（主域名）:8080（端口号）/script/jquery.js（请求资源）

    因为JavaScript同源策略的限制，a.com域名下的js无法操作b.com或是c.a.com域名下的对象

    当协议、子域名、主域名、端口号中任意一个不相同时，都算作不同域。不同域之间相互请求资源，就算作“跨域”

25. ##### 解决跨域的方法有多少种

    https://www.cnblogs.com/sdcs/p/8484905.html

    1. JSONP
    2. CORS
    3. WebSocket
    4. postMessage
    5. document.domain + iframe（只有在主域相同的时候才能使用该方法）
    6. 动态创建script
    7. location.hash + iframe
    8. window.name + iframe

26. ##### 什么是同源协议

    域名同协议同域名同端号

27. ##### indexOf是什么类型的方法

    String类型和数组的方法

28. ##### js数据类型有哪些？

    基本数据类型：Number、String、Boolean、Undefined、Null、Symbol、BigInt

    引用数据类型：Object（包括Array、Function）

    总共8个数据类型

29. ##### 什么是隐式转换？

    一个类型转换成另一个类型，比如一个字符串与一个数字相加那么数字就会转换成字符与字符串拼接

30. ##### typeof可以返回哪些数据类型？

    string， number，boolean， undefined，object，function，symbol

31. ##### instanceof的作用是什么？

    判断一个引用类型变量所指向的对象是否是一个类的实例

32. ##### js在IE 和标准下兼容的写法有哪些？

    ```javascript
    // 1、获取事件对象
    event = event || window.event;
    // 2、事件委托
    var src = event.target || event.srcElement;
    // 3、获得键盘属性
    var code = event.which || event.keyCode;
    // 4、阻止事件冒泡
    event.stopPropagation ? event.stopPropagation() : event.cancelBubble = true;
    // 5、阻止默认事件
    event.preventDefault ? event.preventDefault() : event.returnValue = false;
    // 6、IIFE 立即调用函数
    (funciton name(){})()
    // 7、窗口宽高 
    var width = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
    // 8、滚动宽高
    var top = document.documentElement.scrollTop || document,body.scrollTop;
    // 9、事件监听
    element.addEventListener ? element.addEventListener(type,callback,boolean) : element.attachEvent("on" + type,callback)
    // 10、删除监听式绑定事件
    element.removeEventListener ? element.removeEventListener(type,callback,boolean) : element.detachEvent("on" + type,callback)
    // 11、获得最终生效样式(获取非行内样式)
    window.getComputedStyle ? window.getComputedStyle(element) : element.currentStyle
    ```

    

33. ##### ajax下面的get方法和post方法的区别？

    1. 传参的方式

       get是把参数拼接url后边

       post是把请求参数放到请求体当中

    2. 传参的大小限制

       get谷歌1kb IE2kb；大小限制是因为浏览器对url大小的限制造成的

       post没有大小限制

    3. post方式要相对于get方式安全

    4. get方式有缓存的，post没有缓存

34. ##### ajax如何解析json数据？

    使用JSON.parse()方法把字符串转换为json对象

35. ##### 如何阻止事件冒泡？

    ```javascript
    event.stopPropagation ? event.stopPropagation() : event.cancelBubble = true;
    ```

    

36. ##### 如何阻止默认事件？

    ```
    event.preventDefault ? event.preventDefault() : event.returnValue = false;
    ```

    

37. ##### 如何添加节点、创建节点

    添加节点：element.appendChild(xxx)

    创建节点：document.createElement

38. ##### 数组有哪些方法？

    | 方法                                                         | 描述                                                 |
    | :----------------------------------------------------------- | :--------------------------------------------------- |
    | [concat()](https://www.runoob.com/jsref/jsref-concat-array.html) | 连接两个或更多的数组，并返回结果。                   |
    | [copyWithin()](https://www.runoob.com/jsref/jsref-copywithin.html) | 从数组的指定位置拷贝元素到数组的另一个指定位置中。   |
    | [entries()](https://www.runoob.com/jsref/jsref-entries.html) | 返回数组的可迭代对象。                               |
    | [every()](https://www.runoob.com/jsref/jsref-every.html)     | 检测数值元素的每个元素是否都符合条件。               |
    | [fill()](https://www.runoob.com/jsref/jsref-fill.html)       | 使用一个固定值来填充数组。                           |
    | [filter()](https://www.runoob.com/jsref/jsref-filter.html)   | 检测数值元素，并返回符合条件所有元素的数组。         |
    | [find()](https://www.runoob.com/jsref/jsref-find.html)       | 返回符合传入测试（函数）条件的数组元素。             |
    | [findIndex()](https://www.runoob.com/jsref/jsref-findindex.html) | 返回符合传入测试（函数）条件的数组元素索引。         |
    | [forEach()](https://www.runoob.com/jsref/jsref-foreach.html) | 数组每个元素都执行一次回调函数。                     |
    | [from()](https://www.runoob.com/jsref/jsref-from.html)       | 通过给定的对象中创建一个数组。                       |
    | [includes()](https://www.runoob.com/jsref/jsref-includes.html) | 判断一个数组是否包含一个指定的值。                   |
    | [indexOf()](https://www.runoob.com/jsref/jsref-indexof-array.html) | 搜索数组中的元素，并返回它所在的位置。               |
    | [isArray()](https://www.runoob.com/jsref/jsref-isarray.html) | 判断对象是否为数组。                                 |
    | [join()](https://www.runoob.com/jsref/jsref-join.html)       | 把数组的所有元素放入一个字符串。                     |
    | [keys()](https://www.runoob.com/jsref/jsref-keys.html)       | 返回数组的可迭代对象，包含原始数组的键(key)。        |
    | [lastIndexOf()](https://www.runoob.com/jsref/jsref-lastindexof-array.html) | 搜索数组中的元素，并返回它最后出现的位置。           |
    | [map()](https://www.runoob.com/jsref/jsref-map.html)         | 通过指定函数处理数组的每个元素，并返回处理后的数组。 |
    | [pop()](https://www.runoob.com/jsref/jsref-pop.html)         | 删除数组的最后一个元素并返回删除的元素。             |
    | [push()](https://www.runoob.com/jsref/jsref-push.html)       | 向数组的末尾添加一个或更多元素，并返回新的长度。     |
    | [reduce()](https://www.runoob.com/jsref/jsref-reduce.html)   | 将数组元素计算为一个值（从左到右）。                 |
    | [reduceRight()](https://www.runoob.com/jsref/jsref-reduceright.html) | 将数组元素计算为一个值（从右到左）。                 |
    | [reverse()](https://www.runoob.com/jsref/jsref-reverse.html) | 反转数组的元素顺序。                                 |
    | [shift()](https://www.runoob.com/jsref/jsref-shift.html)     | 删除并返回数组的第一个元素。                         |
    | [slice()](https://www.runoob.com/jsref/jsref-slice-array.html) | 选取数组的的一部分，并返回一个新数组。               |
    | [some()](https://www.runoob.com/jsref/jsref-some.html)       | 检测数组元素中是否有元素符合指定条件。               |
    | [sort()](https://www.runoob.com/jsref/jsref-sort.html)       | 对数组的元素进行排序。                               |
    | [splice()](https://www.runoob.com/jsref/jsref-splice.html)   | 从数组中添加或删除元素。                             |
    | [toString()](https://www.runoob.com/jsref/jsref-tostring-array.html) | 把数组转换为字符串，并返回结果。                     |
    | [unshift()](https://www.runoob.com/jsref/jsref-unshift.html) | 向数组的开头添加一个或更多元素，并返回新的长度。     |
    | [valueOf()](https://www.runoob.com/jsref/jsref-valueof-array.html) | 返回数组对象的原始值。                               |

39. ##### onload 和 onready的区别

    1. onready比onload先执行

       执行时间：window.onload必须等到页面内包括图片的所有元素加载完毕后才能执行。$(document).ready()是DOM结构绘制完毕后就执行，不必等到加载完毕。

    2. onload只执行最后一个而onready可以执行多个。

       编写个数不同时window.onload不能同时编写多个，如果有多个window.onload方法，只会执行一个。$(document).ready()可以同时编写多个，并且都可以得到执行

       ps：$(document).ready(function(){})可以简写成$(function(){});

40. ##### 什么是jsonP

    https://blog.csdn.net/hansexploration/article/details/80314948

    JSONP是一种便于客户端使用数据的非正式传输协议，该协议的一个要点就是允许用户传递一个callback参数给服务端，然后服务端返回数据时会将callback参数作为函数名来包裹住JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了

41. ##### 对this的理解

    https://blog.csdn.net/im_dogg/article/details/93892966?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase

    this对象是在运行时基于函数的执行环境绑定的，谁调用this就是谁。

    如果在全局环境中，this就是window，如果在对象内部，this就指向这个对象。

    闭包不属于对象的属性或方法，所以在闭包中的this是指向window的。

42. ##### 在闭包，这个this的指向

    闭包不属于对象的属性或方法，所以在闭包中的this是指向window的

43. ##### js事件流模型有哪些

    冒泡事件流：当触发一个节点的事件时，会从当前节点开始、依次触发其祖先节点的同类型事件，直到DOM根节点

    捕获事件流：当触发一个节点时，会从DOM根节点开始，依次触发其祖先节点的同类型事件，直到当前节点自身

    DOM事件流：dom同时支持两种事件模型，但捕获事件先开始，从document开始也结束语document，dom模型的独特之处在于文本也可以触发事件

    http://www.fly63.com/article/detial/7905

44. ##### 事件冒泡与事件捕获？

    当使用addEventListener绑定事件，第三个参数设为true时表示事件捕获，除此之外的所有事件均为事件冒泡。

45. ##### typeof null返回什么数据类型

    返回的值是string类型，返回的数据类型是object

46. ##### new操作符做了什么事情？

    1. 创建一个空对象，并且this表变量引用该对象，同时还继承了该函数的原型
    2. 属性和方法被加入到this引用的对象中
    3. 新创建的对象由this所引用、并且最后隐式的返回this

47. ##### js延时加载的方式有哪些

    js延迟加载就是等页面加载完成之后再加载js文件

    一般有六种方式：

    1. defer属性
    2. async属性
    3. 动态创建dom方式
    4. 使用jQuery的getScript方法
    5. 使用setTimeout延迟方法
    6. js文件放在html底部最后加载

48. ##### 如何获取一个数组的最大值和最小值

    ```javascript
    function getMinAndMax(arr) {
    	arr.sort((a,b) => a-b)
        let min = arr[0];
        let max = arr.pop();
        return([min,max])
    }
    ```

50. ##### 什么是cookie

    cookie是计算机上存储在小的文本文件中的数据，存储量很小4kb，存放在客户端上和应用设备上

51. ##### 程序中捕获异常的方法

    try-catch语句

52. ##### innerHTML和outerHTML有什么区别？

    innerHTML是DOM元素的内容和子元素

    outerHTML包括DOM元素自身及其内容和子元素

53. ##### 什么是浅拷贝，什么是深拷贝？

    浅拷贝：将原对象/原数组的引用，直接赋给新对象/新数组，新对象/新数组只是原对象的一个引用，此时当一个对象的属性的引用值发生改变时，会导致另一个也改变

    深拷贝：是指创建一个新的对象和数组，将原对象的各项属性的“值”（数组的所有元素）拷贝过来，是“值”而不是“引用”，我们希望在改变新的对象和数组的时候，不改变原对象和原数组

54. ##### 写一个函数，清除字符串前后所有的空格，兼容所有的浏览器？

    ```javascript
    function myTrim(str){
    	String.prototype.trim ? str.trim() : return str.replace(/(^\s+)|(\s+$)/g, '')
    }
    ```

    

55. ##### 如何实现深拷贝？

    ```javascript
    function deepCopy(data){
        if(typeof data === 'object'){
            let val = data instanceof Array ? []:{};
            for(let i in data){
                val[i] = deepCopy(data[i]);
            }
            return val;
        }else{
            return data
        }
    }
    ```

    

56. ##### 什么是短路操作

    ||(逻辑或)：只有前后都是false的时候才返回false，否则返回true

    &&(逻辑与)：只有前后都是true的时候才返回true，否则返回false

57. ##### 什么是JavaScript

    JavaScript是一种脚本语言，一种轻量级的编程语言，主要用户web。用于增强HTML页面，通常可以嵌入HTML代码中。JavaScript是一种解释型语言。因此，它不需要编译。JavaScript以交互式的方式呈现网页。这允许页面对事件做出反应，展示特殊效果，接受可变文本，验证数据，创建cookie，检测用户的浏览器等

58. ##### 怎么把一行代码分成几行运行

    1. 模板字符串
    2. 斜杠\

59. ##### 什么是未声明的变量和未定义的变量

    未声明的变量：没有用var、let、const关键字和隐式声明的变量

    未定义的变量：声明了但没有赋值的变量

60. ##### 什么是全局变量

    全局变量就是在函数外面声明的变量

61. ##### 使用全局变量会产生什么问题

    会造成变量污染

62. ##### cookie和session的区别

    1. cookie数据存放在客户的浏览器上，session数据存放在服务器上
    2. cookie不是很安全，别人可以解析存放在本地的cookie并进行coolie欺骗，考虑到安全应当使用session
    3. session会在一定时间内保存在服务器上，当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用cookie
    4. 单个coolie保存的数据不能超过4k，很多浏览器都限制一个站点最多保存20个coolie
    5. session保存在服务器，客户端不知道其中的信息；coolie保存在客户端，服务器能够知道其中的信息
    6. session中保存的是对象，coolie中保存的是字符串
    7. session不能区分路径，同一个用户在访问一个网站期间，所有的session在任何一个任何一个地方都可以访问到，而cookie中如果设置路径参数，那么在同一个网站中不同路径下的cookie互相是访问不到的

63. ##### loacalStorage和sessionStorage的区别

    1. 数据有效期不同，sessionStorage仅在当前浏览器窗口关闭之前有效；localStorage始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据

    2. 作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localStorage在所有同源窗口中都是共享的

       

64. ##### js有哪几种错误类型

    1. Error基类型，是所有错误类型的父类，其他的错误类型都继承自它。一般由浏览器抛出，这个基类主要是用于开发人员抛出自定义的错误类型
    2. EvalError表示全局函数eval()的使用方式与定于的不同时抛出，但是实际上并不能产生这个错误，所以遇到的可能性接近0
    3. RangeError(范围错误)，错误类型一般在数值超出相应的范围时发生
    4. ReferenceError(引用错误)，错误类型一般发生在未定义，或不存在时产生
    5. SyntaxError(语法错误)，指的是语法错误导致的报错信息
    6. TypeError(类型错误)，
    7. URLError，在使用encodeURL()和decodeURL()，如果url的格式不正确，就会导致URLError错误，但是这类错误基本上看不懂，因为URL的兼容性非常强大

65. ##### 对象属性如何获取

    1.如果属性名称是字符串，可以使用obj.name和obj[“name”]两种方式来获取属性值
    2.如果属性名称是一个变量，只能使用中括号obj[name]来获取

66. ##### 什么是严格模式

    'use strict'

    严格模式下你不能使用未声明的变量

    严格模式的特点：

    1. 不允许使用隐式声明的变量
    2. 不允许函数有相同的参数，对象有相同的属性
    3. 不允许对只读属性赋值
    4. 禁止this关键字指向全局对象，也就是说this不能指向window顶层对象
    5. 不允许使用保留关键字
    6. 创设eval作用域，在作用域eval()创建的变量不能在外部被调用。

    支持严格模式的浏览器：Internet Explorer 10 +、 Firefox 4+ Chrome 13+、 Safari 5.1+、 Opera 12+

67. ##### es6字符串插值

    当使用模板字符串时，可以用${}来进行插值

68. ##### 怎么样启用块级作用域

    使用let和const声明的变量, 只在当前大阔号内生效, 由此构建出了 **块级作用域** 这么个东西

69. ##### 什么是解构赋值

    解构赋值允许你使用类似数组或对象字面量的语法将数组和对象的属性赋给各种变量。

70. ##### for of的作用

    for-of循环用于遍历数据——比如数组中单值。

    for-of循环不仅仅是为遍历数组而设计的。基本上所有类数组对象都适用

71. ##### Promise有几种状态

    Pending（进行中）、Resolved（已完成，又称Fulfilled）和Rejected（已失败）

72. ##### 什么是模块的导入和导出

    模块导入：import

    模块导出：export

73. ##### 如何在js当中创建私有变量

    http://www.manongjc.com/article/69146.html?tdsourcetag=s_pctim_aiomsg

74. ##### 向内置对象添加自定义方法

    在内置对象的原型链上添加自定义方法

75. ##### 什么是线程和进程

    进程它代表cpu所能处理的单个任务。任一时刻，cpu总是运行一个进程，其他进程处于非运行状态。

    一个进程可以包括多个线程

    一个进程的内存空间是共享的，每个线程都可以使用这些共享内存

    一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存

76. ##### 说说对语义化的理解

    语义化的HTML结构，首先掌握html中各个标签的语义，是一个容器；是表示强调；是一个无序列表等等…在看到内容的时候想想用什么标签能更好的描述它，是什么就用什么标签

77. ##### 从URL输入到网页呈现的过程中，发生了什么？

    [https://blog.csdn.net/weixin_44141866/article/details/106445434?%3E&tdsourcetag=s_pctim_aiomsg](https://blog.csdn.net/weixin_44141866/article/details/106445434?>&tdsourcetag=s_pctim_aiomsg)

    1. 浏览器会根据请求的URL交给DNS域名解析，找到真实的ip，向服务器发起请求。
    2. 服务器交给后台处理后返回数据，浏览器接收文件（HTML、JS、CSS、图像等）
    3. 浏览器对加载到的资源（HTML、css、js）进行语法解析，建立相对应的内部数据结构（如：HTML的DOM）
    4. 载入解析到的资源文件，渲染页面，完成

78. ##### cookie、localStorage和sessionStorage的区别

    1、cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递，而sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下 
    2、存储大小限制也不同，cookie数据不能超过4K，同时因为每次http请求都会携带cookie、所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大 
    3、数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭之前有效；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie：只在设置的cookie过期时间之前有效，即使窗口关闭或浏览器关闭 
    4、作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localstorage在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的 
    5、web Storage支持事件通知机制，可以将数据更新的通知发送给监听者 
    6、web Storage的api接口使用更方便
    https://blog.csdn.net/qq937654393/java/article/details/80877863

79. ##### 节流和防抖的区别

    防抖：当用户一直触发某个函数时，且每次触发函数的间隔小于既定时间，那么防抖的情况下只会执行一次

    节流：当用户一直触发某个函数时，且每次触发小于既定值，函数节流会每隔这个时间调用一次。

    用一句哈总结防抖和节流的区别：防抖是将多次执行变为最后一次执行，节流是将多次执行变为每隔一段时间执行

80. ##### 什么是事件循环机制

    step1：主线程读取JS代码，此时为同步环境，形成相应的堆和执行栈；

    step2:  主线程遇到异步任务，指给对应的异步进程进行处理（WEB API）;

    step3:  异步进程处理完毕（Ajax返回、DOM事件处罚、Timer到等），将相应的异步任务推入任务队列；

    step4: 主线程执行完毕，查询任务队列，如果存在任务，则取出一个任务推入主线程处理（先进先出）；

    step5: 重复执行step2、3、4；称为事件循环。

81. ##### 什么是事件队列

    **js遇到同步代码，会放在执行栈中按照顺序执行，遇到异步代码，js引擎会将它挂起，继续执行下面的同步代码，将异步代码加入到与当前执行栈不同的另一个队列，我们将这个队列称之为事件队列**。被放入事件队列不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕，主线程处于闲置状态时，主线程会去查找事件队列是否有任务。如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码...，如此反复，这样就形成了一个无限的循环。

82. ##### 浏览器的渲染模式

    1. 标准（非怪异）模式
    2. 怪异模式
    3. 部分怪异（近乎标砖）模式

    在标准模式下，浏览器会按照W3C的标准解析和渲染页面，在怪异模式中则尝试模拟更旧的浏览器的行为。一些浏览器也使用一种尝试这两者之间妥协的近乎标准模式，实施了一种表单元格尺寸的怪异行为，除此之外符合标准定义

83. ##### 盒模型有几种模式

    1. 标准盒模型：一个盒子的宽度 = width+padding+border+margin
    2. IE盒模型：一个盒子的宽度 = width+margin（即怪异模式下，width包含了border以及padding）

84. ##### 如何去除页面中的所有空标签

    ```javascript
            function delEmptyTag(tag){
                var children = [...tag.children]
                console.log(children);
                if(children !== []){
                    var length = children.length
                    for(var i = 0; i < length; i++){
                        var child = children[i]
                        children[i].innerHTML === '' ? tag.removeChild(child) : delEmptyTag(child)
                    }
                }
            }
    		var html = document.getElementsByTagName('html')[0]
            delEmptyTag(html)
    ```

    

85. ##### vue优点？

    答：轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十kb；
    简单易学：国人开发，中文文档，不存在语言障碍 ，易于理解和学习；
    双向数据绑定：保留了angular的特点，在数据操作方面更为简单；
    组件化：保留了react的优点，实现了html的封装和重用，在构建单页面应用方面有着独特的优势；
    视图，数据，结构分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作；
    虚拟DOM：dom操作是非常耗费性能的， 不再使用原生的dom操作节点，极大解放dom操作，但具体操作的还是dom不过是换了另一种方式；
    运行速度更快:相比较与react而言，同样是操作虚拟dom，就性能而言，vue存在很大的优势

86. ##### Vue组件间的参数传递

    父传子：

    1. 通过props
    2. 通过$refs
    3. 通过$children

    子传父：

    1. $emit方法
    2. 通过$parent

87. ##### v-show和v-if指令的共同点和不同点？

    答: 共同点：都能控制元素的显示和隐藏；
    不同点：实现本质方法不同，v-show本质就是通过控制css中的display设置为none，控制隐藏，只会编译一次；v-if是动态的向DOM树内添加或者删除DOM元素，若初始值为false，就不会编译了。而且v-if不停的销毁和创建比较消耗性能。
    总结：如果要频繁切换某节点，使用v-show(切换开销比较小，初始开销较大)。如果不需要频繁切换某节点使用v-if（初始渲染开销较小，切换开销比较大）。

88. ##### 如何让CSS只在当前组件中起作用？

    答：在组件中的style前面加上scoped　

89. ##### <keep-alive></keep-alive>的作用是什么?

    答:keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。

90. ##### 如何获取dom?

    答：ref="domName" 用法：this.$refs.domName

91. ##### 说出几种vue当中的指令和它的用法？

    答：v-model双向数据绑定；
    v-for循环；
    v-if v-show 显示与隐藏；
    v-on事件；v-once: 只绑定一次。

92. #####  vue-loader是什么？使用它的用途有哪些？

    答：vue文件的一个加载器，将template/js/style转换成js模块。
    用途：js可以写es6、style样式可以scss或less、template可以加jade等

93. ##### 为什么使用key?（vue中key值的作用）

    答：需要使用key来给每个节点做一个唯一标识，Diff算法就可以正确的识别此节点。
    作用主要是为了高效的更新虚拟DOM。

94. ##### axios及安装?

    答：请求后台资源的模块。npm install axios --save装好，
    js中使用import进来，然后.get或.post。返回在.then函数中如果成功，失败则是在.catch函数中。

95. ##### v-model的使用。(v-model的原理)

    答：v-model用于表单数据的双向绑定，其实它就是一个语法糖，这个背后就做了两个操作：
    v-bind绑定一个value属性；
    v-on指令给当前元素绑定input事件。

96. ##### vue中 key 值的作用？（为什么使用key？）

    需要使用key来给每个节点做一个唯一标识，Diff算法就可以正确的识别此节点。
    作用主要是为了高效的更新虚拟DOM。

97. ##### 请说出vue.cli项目中src目录每个文件夹和文件的用法？

    答：assets文件夹是放静态资源；components是放组件；router是定义路由相关的配置; app.vue是一个应用主组件；main.js是入口文件。

98. ##### 分别简述computed和watch的使用场景

    答：computed:
    　　　　当一个属性受多个属性影响的时候就需要用到computed
    　　　　最典型的栗子： 购物车商品结算的时候
    watch:
    　　　　当一条数据影响多条数据的时候就需要用watch
    　　　　栗子：搜索数据

99. ##### 如何在vue中获取dom节点

    ref="domName" 用法：this.$refs.domName

100. ##### v-model的使用（v-model的原理）

     v-model用于表单数据的双向绑定，其实它就是一个语法糖，这个背后就做了两个操作：
     v-bind绑定一个value属性；
     v-on指令给当前元素绑定input事件。

101. ##### v-on可以监听多个方法吗？怎么写？

     答：可以，例子：

     ```javascript
     <input type="text" v-on="{ input:onInput,focus:onFocus,blur:onBlur, }">
     ```

102. ##### $nextTick的使用

     答：当你修改了data的值然后马上获取这个dom元素的值，是不能获取到更新后的值，
     你需要使用$nextTick这个回调，让修改后的data值渲染更新到dom元素之后在获取，才能成功。

103. ##### vue组件中data为什么必须是一个函数？

     答：因为JavaScript的特性所导致，在component中，data必须以函数的形式存在，不可以是对象。
     　　组建中的data写成一个函数，数据以函数返回值的形式定义，这样每次复用组件的时候，都会返回一份新的data，相当于每个组件实例都有自己私有的数据空间，它们只负责各自维护的数据，不会造成混乱。而单纯的写成对象形式，就是所有的组件实例共用了一个data，这样改一个全都改了。

104. ##### 渐进式框架的理解

     答：主张最少；可以根据不同的需求选择不同的层级

105. ##### Vue中双向数据绑定是如何实现的？

     答：vue 双向数据绑定是通过 数据劫持 结合 发布订阅模式的方式来实现的， 也就是说数据和视图同步，数据发生变化，视图跟着变化，视图变化，数据也随之发生改变；
     核心：关于VUE双向数据绑定，其核心是 Object.defineProperty()方法。

106. ##### 单页面应用和多页面应用区别及优缺点

     答：单页面应用（SPA），通俗一点说就是指只有一个主页面的应用，浏览器一开始要加载所有必须的 html, js, css。所有的页面内容都包含在这个所谓的主页面中。但在写的时候，还是会分开写（页面片段），然后在交互的时候由路由程序动态载入，单页面的页面跳转，仅刷新局部资源。多应用于pc端。
     多页面（MPA），就是指一个应用中有多个页面，页面跳转时是整页刷新
     单页面的优点：
     用户体验好，快，内容的改变不需要重新加载整个页面，基于这一点spa对服务器压力较小；前后端分离；页面效果会比较炫酷（比如切换页面内容时的专场动画）。
     单页面缺点：
     不利于seo；导航不可用，如果一定要导航需要自行实现前进、后退。（由于是单页面不能用浏览器的前进后退功能，所以需要自己建立堆栈管理）；初次加载时耗时多；页面复杂度提高很多。

107. ##### v-if和v-for的优先级

     答：当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级，这意味着 v-if 将分别重复运行于每个 v-for 循环中。所以，不推荐v-if和v-for同时使用。
     如果v-if和v-for一起用的话，vue中的的会自动提示v-if应该放到外层去。

108. ##### assets和static的区别

     答：相同点：assets和static两个都是存放静态资源文件。项目中所需要的资源文件图片，字体图标，样式文件等都可以放在这两个文件下，这是相同点
     不相同点：assets中存放的静态资源文件在项目打包时，也就是运行npm run build时会将assets中放置的静态资源文件进行打包上传，所谓打包简单点可以理解为压缩体积，代码格式化。而压缩后的静态资源文件最终也都会放置在static文件中跟着index.html一同上传至服务器。static中放置的静态资源文件就不会要走打包压缩格式化等流程，而是直接进入打包好的目录，直接上传至服务器。因为避免了压缩直接进行上传，在打包时会提高一定的效率，但是static中的资源文件由于没有进行压缩等操作，所以文件的体积也就相对于assets中打包后的文件提交较大点。在服务器中就会占据更大的空间。
     建议：将项目中template需要的样式文件js文件等都可以放置在assets中，走打包这一流程。减少体积。而项目中引入的第三方的资源文件如iconfoont.css等文件可以放置在static中，因为这些引入的第三方文件已经经过处理，我们不再需要处理，直接上传。

109. ##### vue常用的修饰符

     答：.stop：等同于JavaScript中的event.stopPropagation()，防止事件冒泡；
     .prevent：等同于JavaScript中的event.preventDefault()，防止执行预设的行为（如果事件可取消，则取消该事件，而不停止事件的进一步传播）；
     .capture：与事件冒泡的方向相反，事件捕获由外到内；
     .self：只会触发自己范围内的事件，不包含子元素；
     .once：只会触发一次。

110. ##### vue的两个核心点

     答：数据驱动、组件系统
     数据驱动：ViewModel，保证数据和视图的一致性。
     组件系统：应用类UI可以看作全部是由组件树构成的。

111. ##### vue和jQuery的区别

     答：jQuery是使用选择器（$）选取DOM对象，对其进行赋值、取值、事件绑定等操作，其实和原生的HTML的区别只在于可以更方便的选取和操作DOM对象，而数据和界面是在一起的。比如需要获取label标签的内容：$("lable").val();,它还是依赖DOM元素的值。
     Vue则是通过Vue对象将数据和View完全分离开来了。对数据进行操作不再需要引用相应的DOM对象，可以说数据和View是分离的，他们通过Vue对象这个vm实现相互的绑定。这就是传说中的MVVM。

112. ##### 引进组件的步骤

     答: 在template中引入组件；
     在script的第一行用import引入路径；
     用component中写上组件名称。

113. ##### delete和Vue.delete删除数组的区别

     答：delete只是被删除的元素变成了 empty/undefined 其他的元素的键值还是不变。Vue.delete 直接删除了数组 改变了数组的键值。

114. ##### SPA首屏加载慢如何解决

     答：安装动态懒加载所需插件；使用CDN资源。

115. ##### Vue-router跳转和location.href有什么区别

     答：使用location.href='/url'来跳转，简单方便，但是刷新了页面；
     使用history.pushState('/url')，无刷新页面，静态跳转；
     引进router，然后使用router.push('/url')来跳转，使用了diff算法，实现了按需加载，减少了dom的消耗。
     其实使用router跳转和使用history.pushState()没什么差别的，因为vue-router就是用了history.pushState()，尤其是在history模式下。

116. ##### vue slot

     答：简单来说，假如父组件需要在子组件内放一些DOM，那么这些DOM是显示、不显示、在哪个地方显示、如何显示，就是slot分发负责的活。

117. ##### vue项目是打包了一个js文件，一个css文件，还是有多个文件？

     答：根据vue-cli脚手架规范，一个js文件，一个CSS文件。

118. ##### Vue里面router-link在电脑上有用，在安卓上没反应怎么解决？

     答：Vue路由在Android机上有问题，babel问题，安装babel polypill插件解决。

119. ##### Vue2中注册在router-link上事件无效解决方法

     答： 使用@click.native。原因：router-link会阻止click事件，.native指直接监听一个原生事件。

120. ##### .RouterLink在IE和Firefox中不起作用（路由不跳转）的问题

     答: 方法一：只用a标签，不适用button标签；方法二：使用button标签和Router.navigate方法

121. ##### axios的特点有哪些

     答：从浏览器中创建XMLHttpRequests；
     node.js创建http请求；
     支持Promise API；
     拦截请求和响应；
     转换请求数据和响应数据；
     取消请求；
     自动换成json。
     axios中的发送字段的参数是data跟params两个，两者的区别在于params是跟请求地址一起发送的，data的作为一个请求体进行发送
     params一般适用于get请求，data一般适用于post put 请求。

122. ##### 请说下封装 vue 组件的过程？

     答：1. 建立组件的模板，先把架子搭起来，写写样式，考虑好组件的基本逻辑。(os：思考1小时，码码10分钟，程序猿的准则。)

     　　2. 准备好组件的数据输入。即分析好逻辑，定好 props 里面的数据、类型。
     　　3. 准备好组件的数据输出。即根据组件逻辑，做好要暴露出来的方法。
     　　4. 封装完毕了，直接调用即可

123. ##### params和query的区别

     答：用法：query要用path来引入，params要用name来引入，接收参数都是类似的，分别是this.$route.query.name和this.$route.params.name。
     url地址显示：query更加类似于我们ajax中get传参，params则类似于post，说的再简单一点，前者在浏览器地址栏中显示参数，后者则不显示
     注意点：query刷新不会丢失query里面的数据
     params刷新 会 丢失 params里面的数据。

124. ##### vue初始化页面闪动问题

     答：使用vue开发时，在vue初始化之前，由于div是不归vue管的，所以我们写的代码在还没有解析的情况下会容易出现花屏现象，看到类似于{{message}}的字样，虽然一般情况下这个时间很短暂，但是我们还是有必要让解决这个问题的。
     首先：在css里加上

     ```vue
     [v-cloak] {
     	display: none;
     }。
     ```

     如果没有彻底解决问题，则在根元素加上style="display: none;" :style="{display: 'block'}"

125. ##### vue更新数组时触发视图更新的方法

     答:push()；pop()；shift()；unshift()；splice()； sort()；reverse()

126. ##### vue常用的UI组件库

     答：Mint UI，element，VUX

127. ##### vue修改打包后静态资源路径的修改

     答：cli2版本：将 config/index.js 里的 assetsPublicPath 的值改为 './' 。

     ```javascript
     build: {
     ...
     assetsPublicPath: './',
     ...
     }
     ```

     cli3版本：在根目录下新建vue.config.js 文件，然后加上以下内容：（如果已经有此文件就直接修改）

     ```javascript
     module.exports = {
     publicPath: '', // 相对于 HTML 页面（目录相同） }
     ```

     

128. ##### 什么是 vue 生命周期？有什么作用？

     答：每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做 生命周期钩子 的函数，这给了用户在不同阶段添加自己的代码的机会。（ps：生命周期钩子就是生命周期函数）例如，如果要通过某些插件操作DOM节点，如想在页面渲染完后弹出广告窗， 那我们最早可在mounted 中进行。

129. ##### 第一次页面加载会触发哪几个钩子？

     答：beforeCreate， created， beforeMount， mounted

130. ##### 简述每个周期具体适合哪些场景

     答：**beforeCreate**：在new一个vue实例后，只有一些默认的生命周期钩子和默认事件，其他的东西都还没创建。在beforeCreate生命周期执行的时候，data和methods中的数据都还没有初始化。不能在这个阶段使用data中的数据和methods中的方法
     **create**：data 和 methods都已经被初始化好了，如果要调用 methods 中的方法，或者操作 data 中的数据，最早可以在这个阶段中操作
     **beforeMount**：执行到这个钩子的时候，在内存中已经编译好了模板了，但是还没有挂载到页面中，此时，页面还是旧的
     **mounted**：执行到这个钩子的时候，就表示Vue实例已经初始化完成了。此时组件脱离了创建阶段，进入到了运行阶段。 如果我们想要通过插件操作页面上的DOM节点，最早可以在和这个阶段中进行
     **beforeUpdate**： 当执行这个钩子时，页面中的显示的数据还是旧的，data中的数据是更新后的， 页面还没有和最新的数据保持同步
     **updated**：页面显示的数据和data中的数据已经保持同步了，都是最新的
     **beforeDestory**：Vue实例从运行阶段进入到了销毁阶段，这个时候上所有的 data 和 methods ， 指令， 过滤器 ……都是处于可用状态。还没有真正被销毁
     **destroyed**： 这个时候上所有的 data 和 methods ， 指令， 过滤器 ……都是处于不可用状态。组件已经被销毁了。

131. ##### created和mounted的区别

     答：created:在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成视图。
     mounted:在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作。

132. ##### vue获取数据在哪个周期函数

     答：一般 created/beforeMount/mounted 皆可.
     比如如果你要操作 DOM , 那肯定 mounted 时候才能操作.

133. ##### 请详细说下你对vue生命周期的理解？

     答：总共分为8个阶段创建前/后，载入前/后，更新前/后，销毁前/后。
     创建前/后： 在beforeCreated阶段，vue实例的挂载元素$el和**数据对象**data都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，$el还没有。
     载入前/后：在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。在mounted阶段，vue实例挂载完成，data.message成功渲染。
     更新前/后：当data变化时，会触发beforeUpdate和updated方法。
     销毁前/后：在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在。

134. ##### mvvm 框架是什么？

     答：MVVM——Model-view-view-Model，vue是实现了双向数据绑定的mvvm框架，当视图改变更新模型层，当模型层改变更新视图层。在vue中，使用了双向绑定技术，就是View的变化能实时让Model发生变化，而Model的变化也能实时更新到View。

135. ##### vue-router 是什么?它有哪些组件

     答：vue用来写路由一个插件。router-link、router-view

136. ##### active-class 是哪个组件的属性？

     答：vue-router模块的router-link组件。

137. ##### 怎么定义 vue-router 的动态路由? 怎么获取传过来的值？

     答：在router目录下的index.js文件中，对path属性加上/:id。 使用router对象的params.id。

138. ##### vue-router 有哪几种导航钩子?

     答：三种，
     第一种：是全局导航钩子：router.beforeEach(to,from,next)，作用：跳转前进行判断拦截。
     第二种：组件内的钩子
     第三种：单独路由独享组件

139. ##### $route 和 $router 的区别

     答：$router是VueRouter的实例，在script标签中想要导航到不同的URL,使用$router.push方法。返回上一个历史history用$router.to(-1)
     $route为当前router跳转对象。里面可以获取当前路由的name,path,query,parmas等。

140. ##### vue-router的两种模式

     答:hash模式：即地址栏 URL 中的 # 符号；
     history模式：window.history对象打印出来可以看到里边提供的方法和记录长度。利用了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法。（需要特定浏览器支持）。

141. ##### vue-router实现路由懒加载（ 动态加载路由 ）

     答:三种方式
     第一种：vue异步组件技术 ==== 异步加载，vue-router配置路由 , 使用vue的异步组件技术 , 可以实现按需加载 .但是,这种情况下一个组件生成一个js文件。
     第二种：路由懒加载(使用import)。
     第三种：webpack提供的require.ensure()，vue-router配置路由，使用webpack的require.ensure技术，也可以实现按需加载。这种情况下，多个路由指定相同的chunkName，会合并打包成一个js文件。

142. ##### vuex是什么？怎么使用？哪种功能场景使用它？

     答：vue框架中状态管理。在main.js引入store，注入。
     新建了一个目录store.js，….. export 。
     场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车

143. ##### vuex有哪几种属性？

     答：有五种，分别是 State、 Getter、Mutation 、Action、 Module
     state => 基本数据(数据源存放地)
     getters => 从基本数据派生出来的数据
     mutations => 提交更改数据的方法，同步！
     actions => 像一个装饰器，包裹mutations，使之可以异步。
     modules => 模块化Vuex

144. ##### Vue.js中ajax请求代码应该写在组件的methods中还是vuex的actions中？

     答：如果请求来的数据是不是要被其他组件公用，仅仅在请求的组件内使用，就不需要放入vuex 的state里。
     如果被其他地方复用，这个很大几率上是需要的，如果需要，请将请求放入action里，方便复用。

145. ##### DOCTYPE 有什么作用？怎么写？

     作用：DOCTYPE是document type的简写，它并不是 HTML 标签，也没有结束标签，它是一种标记语言的文档类型声明，即告诉浏览器当前 HTML 是用什么版本编写的，会影响代码验证，并决定了浏览器最终如何显示你的 Web文档。。

     怎么写：DOCTYPE的声明必须是 HTML 文档的第一行，位于html标签之前。

146. ##### 列出常见的标签，并简单介绍这些标签用在什么场景？

     ```xml
     * <a> 用于超链接。<a href="">some text</a>
     * <article> 用于一篇文章。<article>a self-contained article</article>
     * <aside> 用于页面的侧边栏。<aside>some content</aside>
     * <blockquote> 用于大段的引用内容。<blockquote>some big texts</blockquote>
     * <body> 页面上显示的所有内容都被包含在<body></body>里
     * <br> 用于显示一个换行
     * <button> 用于显示一个按钮
     * <code> 用于一包裹一段代码内容
     * <dd> 用于一个dl列表的某个dt名词的描述
     * <del> 用于删除一些不需要的文字
     * <div> 用于包裹住一些其他的标签，制造一个容器
     * <dl> 用于制作一个名词和对应解释的列表
     * <dt> 用于一个dl列表的某个dt名词
     * <em> 用于强调一些文本内容
     * <figcaption> 用于一张图表的说明文字
     * <figure> 用于一张图表
     * <footer> 用于包裹页面的底部内容
     * <form> 用于制作一个表单
     * <h1>-<h6> 用于标记标题，从h1到h6重要性依次递减
     * <head> 用于包裹页面的元数据，如<meta>, <link>, <title>等
     * <header> 用于包裹页面的头部内容
     * <hr> 用于制造出一条分隔线
     * <html> 整个 HTML 文档的根元素，包裹住其他所有的元素
     * <iframe> 用于嵌入另一个小页面到一个页面中
     * <img> 用于显示一张图片
     * <input> 用于显示一个表格输入控件
     * <label> 用于给一个表格输入控件打上一个标签，说明输入控件的作用
     * <li> 用于<ul>和<ol>标签，代表一个列表项
     * <link> 用于链接外部CSS文件
     * <mark> 用于高亮显示某些文本
     * <meta> 用于下达一些元数据指令，或者对页面进行说明
     * <nav> 用于包裹住一个导航条的内容
     * <ol> 用于制作一个有序列表
     * <p> 用于显示一个段落
     * <q> 用于一小段引用文字
     * <script> 用于一段JavaScript脚本代码，或者引入一个外部JavaScript脚本文件
     * <section> 用于包裹一部分有逻辑关第的页面内容
     * <select> 用于制作一个下拉列表选框
     * <span> 用于包裹住一小段文字，作为一个容器
     * <strong> 用于着重强调重要的文本内容
     * <style> 用于给页面元素加上样式
     * <sub> 用于下标文本
     * <sup> 用于上标文本
     * <table> 用于制作一个表格
     * <tbody> 用于表格里的主体部分
     * <td> 用于表格里的某一个单元格
     * <textarea> 用于制作一大块文本输入框
     * <tfoot> 用于表格里的底部
     * <th> 用于表格里的表头的单元格
     * <thead> 用于表格里的表头
     * <time> 用于页面内容中的时间
     * <title> 用于显示整个页面的标题（显示在浏览器的tab上）
     * <tr> 用于标记表格里的一行
     * <ul> 用于制作一个无序列表
     ```

147. ##### 页面出现了乱码，是怎么回事？如何解决？

     乱码问题是由于网页编码不一致导致。

     可以定义网页显示编码解决，用“<meta http-equiv="Content-Type" content="text/html; charset=utf-8″>”

148. ##### title 属性和 alt 属性分别有什么作用？

     - title属性是鼠标划上去显示的内容
     - alt是在图片不能正常加载时候显示的提示语，

149. ##### HTML 的注释怎样写？

     ```html
     <!-- -->
     ```

150. ##### HTML5 为什么只写 <!DOCTYPE HTML> ？

     HTML5 不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行）；

     而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。

     ps: SGML是标准通用标记语言

151. ##### data- 属性的作用？

     data-属性用于储存私有的自定义数据，data-属性可以让我们在所有html元素上增加自定义data属性，存储的data属性能被JavaScript调用。
     data-属性不应该包含任何大写字母，并且在data-后必须最少拥有一个字符，属性值可以是任意字符串

152. ##### WEB 标准以及 W3C 标准是什么？

     **web标准**简单说分为结构，表现，行为（一般指HTML，css，js）。三者独立分开，使其更模块化。

     w3c标准对web标准提出规范化要求。（实际编程中一些代码规范）
     	html（结构）：（标签规范可以提高搜索引擎对页面的抓取效率，对SEO很有帮助）

     1. 标签字母要小写
     2. 标签要闭合
     3. 标签不允许随意嵌套
        css，js：

     4. 尽量使用外链css样式表和js脚本。是结构、表现和行为分为三块，符合规范。同时提高页面渲染速度，提高用户的体验。

     5. 样式尽量少用行间样式表，使结构与表现分离，标签的id和class等属性命名要做到见文知义，标签越少，加载越快，用户体验提高，代码维护简单，便于改版

     6. 不需要变动页面内容，便可提供打印版本而不需要复制内容，提高网站易用性。

153. ##### DOCTYPE 作用? 严格模式与混杂模式如何区分？它们有何意义？

     <!DOCTYPE>声明叫做文件类型定义（DTD），声明的作用为了告诉浏览器该文件的类型。让浏览器解析器知道应该用哪个规范来解析文档。

     **严格模式：**又称标准模式，是指浏览器按照 W3C 标准解析代码。

     **混杂模式：**又称怪异模式或兼容模式，是指浏览器用自己的方式解析代码。

     **如何区分：**浏览器解析时到底使用严格模式还是混杂模式，与网页中的 DTD 直接相关。

     1、如果文档包含严格的 DOCTYPE ，那么它一般以严格模式呈现。**（严格 DTD ——严格模式）** 
     2、包含过渡 DTD 和 URI 的 DOCTYPE ，也以严格模式呈现，但有过渡 DTD 而没有 URI （统一资源标识符，就是声明最后的地址）会导致页面以混杂模式呈现。**（有 URI 的过渡 DTD ——严格模式；没有 URI 的过渡 DTD ——混杂模式）** 
     3、DOCTYPE 不存在或形式不正确会导致文档以混杂模式呈现。**（DTD不存在或者格式不正确——混杂模式）**
     4、HTML5 没有 DTD ，因此也就没有严格模式与混杂模式的区别，HTML5 有相对宽松的语法，实现时，已经尽可能大的实现了向后兼容。**（ HTML5 没有严格和混杂之分）**

     **意义：**严格模式与混杂模式存在的意义与其来源密切相关，如果说只存在严格模式，那么许多旧网站必然受到影响，如果只存在混杂模式，那么会回到当时浏览器大战时的混乱，每个浏览器都有自己的解析模式。

154. ##### HTML 全局属性（Global Attribute）有哪些？

     1. **accesskey**:设置快捷键，提供快速访问元素如aaa在windows下的firefox中按alt + shift + a可激活元素
     2. **class**:为元素设置类标识，多个类名用空格分开，CSS和javascript可通过class属性获取元素
     3. **contenteditable**: 指定元素内容是否可编辑
     4. **contextmenu**: 自定义鼠标右键弹出菜单内容
     5. **data-***: 为元素增加自定义属性
     6. **dir**: 设置元素文本方向
     7. **draggable**: 设置元素是否可拖拽
     8. **dropzone**: 设置元素拖放类型： copy, move, link
     9. **hidden**: 表示一个元素是否与文档。样式上会导致元素不显示，但是不能用这个属性实现样式效果
     10. **id**: 元素id，文档内唯一
     11. **lang**: 元素内容的语言
     12. **spellcheck**: 是否启动拼写和语法检查
     13. **style**: 行内css样式
     14. **tabindex**: 设置元素可以获得焦点，通过tab可以导航
     15. **title**: 元素相关的建议信息
     16. **translate**: 元素和子孙节点内容是否需要本地化

155. ##### meta 有哪些常见的值？

     - content 属性 必选属性
     - name 属性 可选属性
     - http-equiv 属性 可选属性
     - scheme 属性 可选属性
     - charset

156. ##### meta viewport 是做什么用的，怎么写？

     viewport主要是影响移动端页面布局的

     `<meta name="viewport" content="width=device-width, initial-scale=1.0">`

157. ##### 如何在 HTML 页面上展示 <div></div> 这几个字符？

     1. 用转义符号 `&lt;div&gt;&lt;/div&gt;`

     2. 可以用忽略HTML标记

        `<xmp><div></div></xmp>`

        这个标记的作用就是忽略HTML标记的作用，让标记这间的内容直接显示在页面上,

        **ps:这个标签已被废弃**

158. ##### 你是如何理解 HTML 语义化的？

     HTML 标签语义化是让大家直观的通过标签(markup)和属性(attribute)来知道其用途和作用。

     好处：

     1. 清晰的页面结构。去掉或样式丢失的时候,也能让页面呈现清晰的结构，增强页面的可读性。
     2. 支持更多的设备。屏幕阅读器会完全根据你的标记来“读”你的网页。更好的支持浏览器的阅读模式等。
     3. 有利于SEO(搜索引擎优化)。和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息，搜索引擎的爬虫也依赖于标记来确定上下文和各个关键字的权重。
     4. 便于团队开发和维护。在团队中大家都遵循同一个标准，可以减少很多差异化的东西，方便开发和维护，提高开发效率，甚至实现模块化开发。
     5. 方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；

159. ##### 前端需要注意哪些 SEO？

     **什么是SEO：**它是由英文Search Engine Optimization缩写而来，中文意思是“搜索引擎的优化”。

     ​    SEO具体是指通过网站结构调整、网站内容建设、网站代码优化、以及站外优化（网站站外推广、网站品牌建设等），使网站满足搜索引擎的收录排名需求，提高网站在搜索引擎中关键字的排名，从而吸引精准用户进入网站，获得免费流量，产生直接销售或品牌推广。

     **需要注意的：**

     1、 合理的title，description，keyswords 搜索引擎对这三项的权重逐个减小，title 值强调重点即可，重要的关键

     词出现不要超过两次，而且要靠前。

     2 、不同页面的tilte要有所不同；description把页面的内容高度概括，长度合适，不可过分堆叠关键词，不同页面

     description有所不同。keyswords列举出重要的关键词即可。

     3、语义化的HTML代码，符合W3C 规范：语义化代码有利于搜索引擎理解网页。

     4 、重要的内容HTML代码放在前面：搜索引擎抓取HTML 的顺序是从上到下，有的搜索引擎对抓取长度有限制，保

     证重要内容一定会被抓取。

     5 、重要的内容不要用js输出，爬虫不会执行js获取内容。

     6 、尽量少用iframe ，搜索引擎不会抓取iframe中的内容。

     7 、非装饰的图片必须加alt 。

     8 、提高网站速度：网站速度是搜索引擎排序的一个重要指标。

160. ##### POST 和 GET 方式提交数据有什么区别？

     post是向服务器传送数据；get是从服务器上获取数据。

     （1）get的参数会显示在浏览器地址栏中，而post的参数不会显示在浏览器地址栏中；

     （2）使用post提交的页面在点击【刷新】按钮的时候浏览器一般会提示“是否重新提交”，而get则不会；

     （3）用get的页面可以被搜索引擎抓取，而用post的则不可以；

     （4）用post可以提交的数据量非常大，而用get可以提交的数据量则非常小(2k)，受限于网页地址的长度。

     （5）用post可以进行文件的提交，而用get则不可以。

161. ##### 在 input 里，name 有什么作用？

     name：作为可与服务器交互数据的HTML元素的服务器端的标示。

162. ##### label 有什么作用？如何使用？

     作用：label标签来定义表单控制间的关系，当用户选择该标签时，浏览器会自动将焦点转到标签相关的表单控件上。

     如何使用：给相关的表单控件一个id，然后label标签的for属性值设为该id的值

163. ##### radio 如何分组？

     表单中的单选框radio，name相同的是一组

164. ##### placeholder 属性有什么作用？

     placeholder 属性提供可描述输入字段预期值的提示信息（hint）。
     该提示会在输入字段为空时显示，输入内容后会消失

165. ##### type=hidden 隐藏域有什么作用？举例说明。

     隐藏域在页面中对于用户是不可见的，在表单中插入隐藏域的目的在于收集或发送信息，以利于被处理表单的程序所使用。浏览者单击发送按钮发送表单的时候，隐藏域的信息也被一起发送到服务器。

     有些时候我们要给用户一信息，让他在提交表单时提交上来以确定用户身份，如sessionkey，等等．当然这些东西也能用cookie实现，但使用隐藏域就简单的多了．而且不会有浏览器不支持，用户禁用cookie的烦恼。

163. ##### CSS 加载方式有几种？

     **CSS样式加载一共有四种方式：**

     **1、行内样式**

     直接对HTML标签引入style=""设置样式；这样的方式会使得html不干净，代码冗余不利于维护。

     **2、内嵌样式--内部样式表**

     在head标签之间用<style></style>标签声明

     优缺点：页面使用公共CSS代码，也是每个页面都要定义的，如果一个网站有很多页面，每个文件都会变大，后期维护难度也大，如果文件很少，CSS代码也不多，这种样式还是很不错的。

     **3、链入外部样式表—在head部分加入**

     链接样式使用最多，推荐使用的一种方法，在<head></head>标签之间用<link ...../>引入css文件

     **4、导入外部样式表—在head部分加入**

     导入样式和链接样式比较相似，采用@import样式导入CSS样式表，在HTML初始化时，会被导入到HTML或者CSS文件中，成为文件的一部分，类似第二种内嵌样式。

164. ##### @import 有什么作用？如何使用？

     第一种：html源代码（html文件里）直接引入内部格式表CSS文件

     第二种：CSS文件代码中运用@import引入此外一个CSS文件

165. ##### CSS 选择器常见的有几种？

     1. 通用选择器
     2. 标签选择器
     3. 类选择器
     4. 指定标签类选择器
     5. id选择器
     6. 后代选择器
     7. 群组选择器（并集选择器）
     8. 直接子元素选择器
     9. 属性选择器
        - 基于属性是否存在进行选择：标记[属性]
        - 基于属性值进行选择：标记[属性=“值”]
        - 基于以字符串开始的属性值选择器：标记[属性^=“值”]
     10. 相邻元素选择器
     11. 兄弟元素选择器
     12. 伪元素选择器
     13. 伪类选择器
         - 结构化伪类
           1. :root 匹配根元素，html文档中匹配<html>标记
           2. :empty选择器:选取内容为空的标记
           3. :target选择器:选择链接跳转的目标内容
         - 子元素伪类选择器
           1. :first-child 当一个元素是另一个元素的第一个子元素时。
           2. :last-child结构化伪类只用于当一个元素是另一个元素的最后一个子元素时。
           3.  :nth-child(n)结构化伪类只能用于当一个元素是另一个元素的第n个子元素时。从1开始计算
           4. :nth-of-type类同于nth-child
         - 元素状态伪类选择器
           1. E:hover  鼠标指针移动到某个文本框控件上的样式
           2. E:active 元素被激活(鼠标在元素上按下还没有松开)时使用的样式
           3. E:focus  元素获得光标焦点时使用的样式，主要是在文本框控件获得焦点并进行文字输入的时候使用
           4. E:enabled  指定当元素处于可用状态时的样式
           5. E:disabled 指定当元素处于不可用状态时的样式
           6. E:read-only  指定当元素处于只读状态时的样式
           7. E:read-write 指定当元素处于非只读状态时的样式
           8. E:default  指定当页面打开时默认处于选区状态的样式
           9. E::selection 指定当元素处于选中状态时的样式

166. ##### id 选择器和 class 选择器的使用场景分别是什么？

     如果想要一个样式权重高，用id选择器

     如果想要一个样式复用率高，用class选择器

167. ##### @charset 有什么作用？

     在外部样式表文件内使用。指定该样式表使用的字符编码。

168. ##### 简述 src 和 href 的区别？

     src和href都是属于外部资源的引用，像一些图片，css文件，js文件，或者其他的web页面
     他们的之间的主要关系可以用这样的一句话来概括：src用于替换这个元素，而href用于建立这个标签与外部资源的关系

     href (Hypertext Reference) 表示超文本引用，href这个属性指定web资源的位置，从而定义当前元素（如锚点a）或当前文档（如链接）与目标锚点或目标资源之间的联系
     src (Source)源这个属性是将资源嵌入到当前文档中元素所在的位置
     当浏览器解析到src引用的js文件代码时，页面的加载和解析都会暂停直到浏览器拿到并执行完这个js文件。这就像是把js文件里的内容全部注入到这个script标签中，类似于img，img标签是一个空标签，它的内容就是由src这个属性定义，浏览器会暂停加载直到这个图片加载完成。

169. ##### 页面导入时，使用 link 和 @import 有什么区别？

     1. link属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS;
     2. 页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;
     3. @import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题;

170. ##### 伪类选择器有哪些？

     伪类选择器

     - 结构化伪类
       1. :root 匹配根元素，html文档中匹配<html>标记
       2. :empty选择器:选取内容为空的标记
       3. :target选择器:选择链接跳转的目标内容
     - 子元素伪类选择器
       1. :first-child 当一个元素是另一个元素的第一个子元素时。
       2. :last-child结构化伪类只用于当一个元素是另一个元素的最后一个子元素时。
       3.  :nth-child(n)结构化伪类只能用于当一个元素是另一个元素的第n个子元素时。从1开始计算
       4. :nth-of-type类同于nth-child
     - 元素状态伪类选择器
       1. E:hover  鼠标指针移动到某个文本框控件上的样式
       2. E:active 元素被激活(鼠标在元素上按下还没有松开)时使用的样式
       3. E:focus  元素获得光标焦点时使用的样式，主要是在文本框控件获得焦点并进行文字输入的时候使用
       4. E:enabled  指定当元素处于可用状态时的样式
       5. E:disabled 指定当元素处于不可用状态时的样式
       6. E:read-only  指定当元素处于只读状态时的样式
       7. E:read-write 指定当元素处于非只读状态时的样式
       8. E:default  指定当页面打开时默认处于选区状态的样式
       9. E::selection 指定当元素处于选中状态时的样式

171. ##### 伪元素和伪类的区别？

     伪元素是在dom文档中创建了一个虚拟元素

     伪类类似于一个类选择器

172. ##### 选择器的优先级是如何计算的？

     !important > 行内样式>ID选择器 > 类选择器 > 标签 > 通配符 > 继承 > 浏览器默认属性

173. ##### 什么是 CSS 继承？哪些属性能继承，哪些不能？

     CSS继承可定义为特定的css属性向下传递到子孙元素，就是指被包在内部的标签将拥有外部标签的样式，即子元素可以继承父元素的属性。

     - **能继承的属性：**

     **1. 字体系列属性:**font、font-family、font-weight、font-size、font-style;
     **2. 文本系列属性:**
     （1）内联元素：color、line-height、word-spacing、letter-spacing、text-transform;
     （2）块级元素：text-indent、text-align;
     **3. 元素可见性：**visibility
     **4. 表格布局属性：**caption-side、border-collapse、border-spacing、empty-cells、table-layout;
     **5. 列表布局属性：**list-style
     **6. 生成内容属性：**quotes
     **7. 光标属性：**cursor
     **8. 页面样式属性：**page、page-break-inside、windows、orphans;
     **9. 声音样式属性：**speak、speech-rate、volume、voice-family、pitch、stress、elevation;

     - **不能继承的属性：**

     **1. display：**规定元素应该生成的框的类型；
     **2. 文本属性：**vertical-align、text-decoration;
     **3. 盒子模型的属性：**width、height、margin 、border、padding;
     **4. 背景属性：**background、background-color、background-image;
     **5. 定位属性：**float、clear、position、top、right、bottom、left、min-width、min-height、max-width、max-height、overflow、clip;
     **6. 生成内容属性：**content、counter-reset、counter-increment;
     **7. 轮廓样式属性：**outline-style、outline-width、outline-color、outline;
     **8. 页面样式属性：**size、page-break-before、page-break-after;
     **9. 声音样式属性：**pause、cue、play-during;

174. ##### px，em，rem，vw 有什么区别？

     **px**就是pixel的缩写，意为像素。px就是一张图片最小的一个点，一张位图就是千千万万的这样的点构成的，比如常常听到的电脑像素是1024x768的，表示的是水平方向是1024个像素点，垂直方向是768个像素点。

     **em**参考物是父元素的font-size，具有继承的特点

     **rem**相对于根元素html（网页）的font-size

     **vw**视窗宽度，1vw等于视窗宽度的1%。

175. ##### 块级元素和行内元素分别有哪些？ 空（void）元素有那些？块级元素和行内元素有什么区别？

     块级元素：`div ul ol li dl dt dd h1 h2 h3 h4 h5 h6 p`

     行内元素：`a b span img input select strong`

     空（void）元素：`<br> <hr> <img> <input> <link> <meta>`

     区别：

     - 区别一：

     　　　　块级：块级元素会独占一行，默认情况下宽度自动填满其父元素宽度

     　　　　行内：行内元素不会独占一行，相邻的行内元素会排在同一行。其宽度随内容的变化而变化。

     - 区别二：

     　　　　块级：块级元素可以设置宽高

     　　　　行内：行内元素不可以设置宽高

     - 区别三：

     　　　　块级：块级元素可以设置margin，padding

     　　　　行内：行内元素水平方向的margin-left; margin-right; padding-left; padding-right;可以生效。但是竖直方向的margin-bottom; margin-top; padding-top; padding-bottom;却不能生效。

     - 区别四：

     　　　　块级：display:block;

     　　　　行内：display:inline;

176. ##### 在什么场景下会出现外边距合并？如何合并？如何不让相邻元素外边距合并？给个父子外边距合并的范例？

     ###### 合并外边距的场景：

     - 外边距合并的必备条件：margin必须是邻接的
     - 两个margin是邻接的必需满足以下条件：

     1、必须是处于常规文档流（非float和绝对定位）的块级盒子，并且处于同一个BFC当中

     2、没有线盒，没有空隙，没有padding和border将他们分隔开

     3、都属于垂直方向上相邻的外边距，可以是下面任意一种情况：

     <1>:元素的margin-top与其第一个常规文档流的子元素的margin-top

     <2>:元素的margin-bottom与其下一个常规文档流的兄弟元素的margin-top

     <3>:height为auto的元素的margin-bottom与其最后一个常规文档流的子元素的margin-bottom

     <4>:高度为0并且最小高度也为0，不包含常规文档流的子元素，并且自身没有建立斤的BFC(Block formating context直译为“块级格式化上下文”)的元素的margin-top和margin-bottom

     ###### 合并后margin计算规则

     - 兄弟元素

     ![img](https://upload-images.jianshu.io/upload_images/11362974-b6879d790a913e8d.png?imageMogr2/auto-orient/strip|imageView2/2/w/549/format/)

     

     - 父子元素

     ![img](https://upload-images.jianshu.io/upload_images/11362974-a077f93561d67709.png?imageMogr2/auto-orient/strip|imageView2/2/w/562/format/webp)

     

     - 空元素

     ![img](https://upload-images.jianshu.io/upload_images/11362974-0606cc2b4d3ce618.png?imageMogr2/auto-orient/strip|imageView2/2/w/593/format/webp)

     

     - 以上三种混合

     ![img](https://upload-images.jianshu.io/upload_images/11362974-2a795214abb6b76d.png?imageMogr2/auto-orient/strip|imageView2/2/w/600/format/webp)

     ###### 如何不让相邻元素外边距合并

     1. 可以只设置下边距或者上边距
     2. 让父级元素触发 BFC，就能使父级 margin 和当前元素的 margin 不重叠
     3. 设置border

177. ##### line-height: 2; 和 line-height: 200%; 有什么区别?

     line-height: 2 表示单行文本的行高为它本身的两倍
     line-height: 200% 表示单行文本的行高为系统默认字体的200%

178. ##### 行内元素的“边框”、“边界”等“框属性”是由 font-size 还是 line-height 控制？

     行内元素的“边框”、“边界”等“框属性”是由 font-size控制

179. ##### height=line-height 可以用来垂直居中单行文本？代码怎么实现？

     可以。设置height和line-height的值相同

180. ##### inline-block 有什么特性？

     - 既呈现 inline 特性(不占据一整行，宽度由内容宽度决定)
     - 又呈现 block 特性 (可设置宽高，内外边距)
     - 默认情况下，inline-block元素之间就有空隙出现

181. ##### inline-block 在实际工作中有什么作用？

     用于精灵图

     当元素需要块级元素的属性又需要成一行时

182. ##### 怎么去除两个按钮中间的缝隙问题？

     第一种是设他们父级的字体大小为0（极不推荐使用）

     第二种是两个button的html代码不要换行

183. ##### 一个页面有一排高度不一样的产品图，这时如果我们用 inline-block ，怎样使他们“顶端对齐”？

     1. 设置 `vertical-align: text-top`
     2. 使用弹性布局

184. ##### 让一个元素“看不见”有几种方式？有什么区别？

     1. display：none，这种方式可以使元素彻底从文档中删除，会造成浏览器的回流与重绘
     2. visibility：hidden，元素会从页面中消失，它原本占据的空间会被保留，会造成浏览器的重绘，适用于希望元素隐藏又不影响页面布局的场景，但是该属性会被子元素继承，所以若不希望子元素隐藏，还需在子元素中设置visibility：visible。
     3. opacity：0
        opacity属性表示元素的透明度，而将元素的透明度设置为0后，在我们用户眼中，元素也是隐藏的，这算是一种隐藏元素的方法。但是它仍然存在与页面中。

185. ##### 单行文本溢出加 ... 如何实现？

     ```css
      white-space: nowrap; /* 文本不换行 */
      overflow: hidden;    /* 溢出文本隐藏 */
      text-overflow: ellipsis; /* 溢出文本省略
     ```

186. ##### 如何在页面上实现一个圆形的可点击区域？

     设置元素宽高相同，并且设置border-radius为50%

187. ##### 浮动元素有什么特征？对父容器、其他浮动元素、普通元素、文字分别有什么影响？

     ###### 特征

     - 任何定义为float的元素都会自动被设置为一个块状元素显示，相当于被定义display：block；声明。这样就可以为浮动元素定义width和height属性，即使是内联显示元素也可以。
     - 当我们没有指定浮动元素宽度时，浮动元素会自动收缩到能够包含内容的宽度。而块状元素（或者被定义display：block；）显示时，如果没有定义，它的宽度则会自动显示为100%。
     - 浮动模型不会与流动模型发生冲突，当元素定义为浮动布局时，它在垂直方向上应该还处于文档流中，也就是说浮动元素不会脱离正常文档流而任意浮动，它的上边线将会与未被声明为浮动时的位置一样，但是在水平方向上，它的浮动边会尽可能的靠近它的包含元素边缘。
     - 与普通元素一样，浮动元素始终位于包含元素内，不会游离于外，或破坏元素包含关系。
     - 浮动元素后面的块状元素和内联元素都能够以流的形式环绕浮动元素左右。甚至于上面文本流连成一体。
     - 当两个或两个以上的相邻元素都被定义为浮动显示时，如果存在足够的空间容纳它们，浮动元素之间可以并列显示，它们的上边线是在同一水平线上。如果没有足够空间那么后面的浮动元素将会下移到能够容纳它的地方这个向下移动的元素有可能产生一个单独的浮动。

     ###### 对父容器的影响

     浮动元素脱离文档流向左或者向右移动，直到边框碰到父元素的边缘。可能会造成父容器高度塌陷

     ###### 对其他浮动元素的影响

     当一个浮动元素在浮动过程中碰到同一个方向的浮动元素时，它会紧跟在它们后面，当空间不够的时候会被浮动元素卡住。

     ###### 对普通元素的影响

     普通元素无法感知到浮动元素，占据浮动元素所在的位置，但是普通元素处于浮动元素的下层。

     ###### 对文字的影响

     浮动元素旁边的文字框被缩短，从而给浮动元素留出空间，文字框围绕浮动元素。

188. ##### 清除浮动指什么？如何清除浮动？两种以上方法。

     在非IE浏览器（如Firefox）下，当容器的高度为auto，且容器的内容中有浮动（float为left或right）的元素，在这种情况下，容器的高度不能自动伸长以适应内容的高度，使得内容溢出到容器外面而影响（甚至破坏）布局的现象。这个现象叫浮动溢出，为了防止这个现象的出现而进行的CSS处理，就叫CSS清除浮动。

     清浮动的方法：

     1. 过在浮动元素末尾添加一个空的标签例如 `<div style="clear:both"></div>`
     2. 使用 br标签和其自身的 html属性，br 有 clear=“all | left | right | none” 属性
     3. 父元素设置 overflow：hidden
     4. 父元素设置 overflow：hidden
     5. 父元素也设置浮动
     6. 父元素设置display：table
     7. 父元素设置高度
     8. 使用::after伪元素

189. ##### 有几种定位方式？分别是如何实现定位的？参考点是什么？使用场景是什么？

     CSS 有三种基本的定位方式：文档流、浮动和定位。

     - 文档流(normal flow)： 文档流是所有元素布局的基础，作为从左到右、从上到下的布局方式，这是最常用的一种排版布局方式。
     - 浮动(float)：float:left/right；浮动的框可以向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。由于浮动框不在文档的普通流中，所以文档的普通流中的块框表现得就像浮动框不存在一样。适用于实现文字环绕图片和多列布局。
     - 定位(position)有以下四种方式：

     | 定位方式 | 实现方式                                                     | 使用场景                                   |
     | -------- | ------------------------------------------------------------ | ------------------------------------------ |
     | static   | 默认布局，按照文档流定位；                                   | 默认布局；                                 |
     | relative | 相对于元素自身正常位置进行定位，元素在文档流中仍占据原来空间，只是表现出来的位置会相对原来的位置偏移； | 适用于层叠效果；                           |
     | absolute | 绝对定位，相对于有定位属性的第一个父元素偏移，absolute定位元素会脱离文档流； | 适用于小区块的布局使用频繁                 |
     | fixed    | 相对浏览器窗口定位，设置的偏移属性，是相对于浏览器窗口的位置。 | 适用于广告等意图一直出现在用户眼前的信息。 |

190. ##### z-index 有什么作用？如何使用？

     可以解决元素的覆盖问题，决定那个元素在上方，哪一个在下方；
     z-index的值可以是负数，也可以为0，也可以无群大，数值大的在上方；

     在使用之前需要给元素设置position属性

191. ##### BFC 是什么？如何生成 BFC？BFC 有什么作用？举例说明。

     ###### BFC是什么

     BFC是“Box Formating Context”指得是“块级格式化上下文”，它是一个独立的块级渲染区域，这个区域拥有自己的规则来约束块级盒子的布局，并且这种布局与区域外部无关

     ###### 如何生成BFC（触发条件）

     1. float的值不为none
     2. position的值为absolute或fixed
     3. overflow的属性值不为visible
     4. display的值为inline-block、table-cell、table-caption

     ###### BFC作用

     1. 防止外边距合并
     2. 防止正常文档流中元素占据浮动元素的位置
     3. 消除文字围绕浮动元素
     4. 解决浮动元素造成的高度塌陷

192. ##### 如何使用伪元素来清除浮动？

     ```css
     ::after{
         content: '';
         display: block;
         clear: both;
     }
     ```

     

193. ##### 可以通过哪些方法优化 CSS3 Animation 渲染？

     1. box-shadow和gradients是页面的性能杀手，计算他们尤其消耗cpu，所以尽量避免使用

     2. 在使用css3 transtion做动画效果时，优先选择transform，尽量不要使用height，width，margin和padding。

        写动画的时候写个这个，保证能刚10%以上；

        ```css
        -webkit-transform: translate3d(0, 0, 0);
        -moz-transform: translate3d(0, 0, 0);
        -ms-transform: translate3d(0, 0, 0);
        transform: translate3d(0, 0, 0);
        ```

194. ##### 如何让块级元素水平居中？如何让行内元素水平居中？如何让 inline-block 元素水平居中？

     ###### 让块级元素水平居中：

     设置固定宽度，用margin：0 auto

     ###### 让行内元素水平居中：

     text-align：center

     ###### 让inline-block元素水平居中：

     text-align：center

195. ##### 垂直上下居中的办法？

     1. height = line-height
     2. 弹性布局
     3. 网格布局
     4. 绝对定位

196. ##### 响应式布局原理？

     响应式布局指的是同一页面在不同屏幕尺寸下有不同的布局。传统的开发方式是PC端开发一套，手机端再开发一套，而使用响应式布局只要开发一套就够，缺点就是`CSS`比较重。

197. ##### 列举你了解的 HTML5、CSS3 新特性？

     https://www.cnblogs.com/star91/p/5659134.html

198. ##### 渐进增强和优雅降级分别是什么意思？

     何谓渐进增强：
      渐进增强（Progressive Enhancement）：一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再针对高级浏览器进行效果、交互、追加功能达到更好的体验。

     何谓优雅降级：
      优雅降级（Graceful Degradation）：一开始就构建站点的完整功能，然后针对浏览器测试和修复。比如一开始使用 CSS3 的特性构建了一个应用，然后逐步针对各大浏览器进行 hack 使其可以在低版本浏览器上正常浏览。

199. ##### 什么是 CSS Hack？在哪个网站查看标签（属性）的浏览器兼容情况？

     不同的浏览器对CSS的解析结果是不同的，因此会导致相同的CSS输出的页面效果不同，这就需要CSS Hack来解决浏览器局部的兼容性问题。而这个针对不同的浏览器写不同的CSS 代码的过程，就叫CSS Hack。

     查看标签（属性）的浏览器兼容情况网站：https://www.caniuse.com

     绿色的是兼容的，红色不兼容，黄色需要加前缀

200. ##### IE6、7 的 Hack 写法是？

     1、属性级Hack：比如IE6能识别下划线””和星号” “，IE7能识别星号” “，但不能识别下划线””，而firefox两个都不能认识。

     2、选择符级Hack：比如IE6能识别html .class{}，IE7能识别+html.class{}或者*:first-child+html .class{}。

     3、IE条件注释Hack：IE条件注释是微软从IE5开始就提供的一种非标准逻辑语句。比如针对所有IE：<!–[ifIE]><!–您的代码–><![endif]–>，针对IE7以下版本：<!–[if lt IE 7]><!–您的代码–><![endif]–>，这类Hack不仅对CSS生效，对写在判断语句里面的所有代码都会生效。

201. ##### CSS Reset 是什么？CSS 预编译器是什么？后编译器（PostCSS）是什么？

     ###### css reset

      即重置浏览器标签的样式表，现在所使用的主流浏览器对一些标签的默认属性上并没有做到统一，所以我们偶尔会发现，某个页面在chrome浏览器上很正常，到了firefox上面却有意想不到的偏差。当然编程人员不喜欢这样的兼容性问题的，而reset.css就是解决默认样式不兼容问题的办法之一。

     ###### css 预编译器

     CSS 预处理器定义了一种新的语言，其基本思想是，用一种专门的编程语言，为 CSS 增加了一些编程的特性，将 CSS 作为目标生成文件，然后开发者就只要使用这种语言进行编码工作。
      CSS 预处理器为 CSS 增加一些编程的特性，无需考虑浏览器的兼容性问题”，例如你可以在 CSS 中使用变量、简单的逻辑程序、函数（如右侧代码编辑器中就使用了变量$color）等等在编程语言中的一些基本特性，可以让你的 CSS 更加简洁、适应性更强、可读性更佳，更易于代码的维护等诸多好处。
      目前主流的预处理器里最常用的三种有：Sass，Less ，Stylus 。

     ###### 后编译器(post css)

     PostCSS是一个使用JavaScript插件来转换CSS的工具。它将CSS转换成抽象语法树(AST)，也就是JavaScript可以操作的一种数据形式。基于JavaScript的PostCSS插件可以执行不同的代码操作。PostCSS本身并没有改变你的CSS，它请允许插件执行和转换你的代码。
      实际上，对于CSS的操作，PostCSS插件并没有任何限制。只要你有想得到的，你都可以写一个PostCSS插件来实现。

202. ##### CSS Reset 和 Normalize.css 有什么区别？

     - CSS Reset，意为重置默认样式。HTML中绝大部分标签元素在网页显示中都有一个默认属性值，通常为了避免重复定义元素样式，需要进行重置默认样式（CSS Reset）。

     - Normalize.css只是一个很小的css文件，但它在默认的HTML元素样式上提供了跨浏览器的高度一致性。相比于传统的css reset，Normalize.css是一种现代的，为HTML5准备的优质替代方案。Normalize.css是一种CSS reset的替代方案。

     区别：

     1.Normalize.css保护了有价值的默认值

     Reset通过为几乎所有的元素施加默认样式，强行使得元素有相同的视觉效果。相比之下，Normalize.css保持了许多默认的浏览器样式。这就意味着你不用再为所有的公共排版元素重新设置样式。当一个元素在不同的浏览器中有不同的默认值时，Normalize.css会力求让这些样式保持一致并可能与现代标准相符合。

     2.Normalize.css修复了浏览器的bug

     它修复了常见的桌面端和移动端浏览器的bug。这往往超出了Reset所能做到的范畴。关于这一点，Normalize.css修复的问题包含了HTML5元素的显示设置，与格式化文字的font-size问题，在IE９中SVG的溢出，许多出现在各浏览器和操作系统中的与表单相关的bug。3.Normalize.css不会让你的调试工具变得杂乱

     使用Reset最让人困扰的地方莫过于在浏览器调试工具中使用大段的继承链。在Normalize.css中就不会有这样的问题，因为在我们的准则中对多选择器的使用是非常谨慎的，我们仅会有目的地对元素设置样式。

     4.Normalize.css是模块化的

     这个项目已经被拆分为多个相关却又独立的部分，这使得你能够很容易也很清楚地知道哪些元素被设置了特定的值。因此这能让你自己选择性地移除掉某些永远不会用到的部分（比如表单的一般化）。

     5.Normalize.css拥有详细的文档

     Normalize.css的代码基于详细而全面的跨浏览器研究与测试。这个文件中拥有详细的代码说明并在Github Wiki中有进一步的说明。这意味着你可以知道到每一行代码具体实现了什么工作，为什么要写这句代码，浏览器之间的差异，并且你可以更容易地实现地进行自己的测试。
     
203. ##### 尽可能多地写出浏览器兼容性问题？

     **浏览器兼容问题一：不同浏览器的标签默认的外补丁和内补丁不同**

     问题症状：随便写几个标签，不加样式控制的情况下，各自的margin 和padding差异较大。

     碰到频率:100%

     解决方案：CSS里 *

     备注：这个是最常见的也是最易解决的一个浏览器兼容性问题，几乎所有的CSS文件开头都会用通配符*来设置各个标签的内外补丁是0。

     **浏览器兼容问题二：块属性标签float后，又有横行的margin情况下，在IE6显示margin比设置的大**

     问题症状:常见症状是IE6中后面的一块被顶到下一行

     碰到频率：90%（稍微复杂点的页面都会碰到，float布局最常见的浏览器兼容问题）

     解决方案：在float的标签样式控制中加入 display:inline;将其转化为行内属性

     备注：我们最常用的就是div+CSS布局了，而div就是一个典型的块属性标签，横向布局的时候我们通常都是用div float实现的，横向的间距设置如果用margin实现，这就是一个必然会碰到的兼容性问题。

     **浏览器兼容问题三：设置较小高度标签（一般小于10px），在IE6，IE7，遨游中高度超出自己设置高度**

     问题症状：IE6、7和遨游里这个标签的高度不受控制，超出自己设置的高度

     碰到频率：60%

     解决方案：给超出高度的标签设置overflow:hidden;或者设置行高line-height 小于你设置的高度。

     备注：这种情况一般出现在我们设置小圆角背景的标签里。出现这个问题的原因是IE8之前的浏览器都会给标签一个最小默认的行高的高度。即使你的标签是空的，这个标签的高度还是会达到默认的行高。

     **浏览器兼容问题四：行内属性标签，设置display:block后采用float布局，又有横行的margin的情况，IE6间距bug**

     问题症状：IE6里的间距比超过设置的间距

     碰到几率：20%

     解决方案：在display:block;后面加入display:inline;display:table;

     备注：行内属性标签，为了设置宽高，我们需要设置display:block;(除了input标签比较特殊)。在用float布局并有横向的margin后，在IE6下，他就具有了块属性float后的横向margin的bug。不过因为它本身就是行内属性标签，所以我们再加上display:inline的话，它的高宽就不可设了。这时候我们还需要在display:inline后面加入display:talbe。

     **浏览器兼容问题五：图片默认有间距**

     问题症状：几个img标签放在一起的时候，有些浏览器会有默认的间距，加了问题一中提到的通配符也不起作用。

     碰到几率：20%

     解决方案：使用float属性为img布局

     备注：因为img标签是行内属性标签，所以只要不超出容器宽度，img标签都会排在一行里，但是部分浏览器的img标签之间会有个间距。去掉这个间距使用float是正道。（我的一个学生使用负margin，虽然能解决，但负margin本身就是容易引起浏览器兼容问题的用法，所以我禁止他们使用）

     **浏览器兼容问题六：标签最低高度设置min-height不兼容**

     问题症状：因为min-height本身就是一个不兼容的CSS属性，所以设置min-height时不能很好的被各个浏览器兼容

     碰到几率：5%

     解决方案：如果我们要设置一个标签的最小高度200px，需要进行的设置为：{min-height:200px; height:auto !ImportAnt; height:200px; overflow:visible;}

     备注：在B/S系统前端开时，有很多情况下我们又这种需求。当内容小于一个值（如300px）时。容器的高度为300px；当内容高度大于这个值时，容器高度被撑高，而不是出现滚动条。这时候我们就会面临这个兼容性问题。

     **浏览器兼容问题七：透明度的兼容CSS设置**

     做兼容页面的方法是：每写一小段代码（布局中的一行或者一块）我们都要在不同的浏览器中看是否兼容，当然熟练到一定的程度就没这么麻烦了。建议经常会碰到兼容性问题的新手使用。很多兼容性问题都是因为浏览器对标签的默认属性解析不同造成的，只要我们稍加设置都能轻松地解决这些兼容问题。如果我们熟悉标签的默认属性的话，就能很好的理解为什么会出现兼容问题以及怎么去解决这些兼容问题。

204. ##### 如何让 Chrome 浏览器显示小于 12px 的文字？

     1. 设置-webkit-text-size-adjust:none;（最新chrome已不支持）
     2. 设置-webkit-transform:scale(0.8);
     3. Chrome浏览器中设置最小字号的显示

205. ##### CSS 预处理器的比较：Less、Sass？

     |      |   主要用途    |    基于    |    运行环境    |        变量         |                     混合                     |       继承        |                             循环                             |
     | ---- | :-----------: | :--------: | :------------: | :-----------------: | :------------------------------------------: | :---------------: | :----------------------------------------------------------: |
     | less | css预处理语言 | JavaScript | Node或浏览器端 | 使用@来声明一个变量 |        混合.class{}<br />调用.class()        | &：extend(.class) |                      通过递归来构建循环                      |
     | sass |  css扩展语言  |    Ruby    |    服务器端    |    变量使用$定义    | 混合使用@mixin声明，<br />调用时必须@include |  @extend .class   | sass也可以用递归来构建循环。但sass平台另外提供了一套循环语法，如下 |

     sass循环语法：

     ```scss
     @mixin test($n){
         @if $n > 0{
             @include test($n - 1);
             .test{
                 width: 100px+$n
             }
         }
     }
     @include test(12);
     @for $a from 1 through 9 {
         .test{
             width: 100px + $a
         }
     }
     ```

     

206. ##### 列举 CSS 编码规范？

     1.CSS命名方式

     - 保持 class 命名为全小写，可以使用短划线（不要使用下划线和 camelCase 驼峰式命名）
     - 短划线应该作为相关类的自然间断。(例如，.btn 和 .btn-blue)。
     - 避免过度使用简写。.btn 可以很好地描述 button，但是 .t 不能代表任何元素。
     - class 的命名应该尽量短，也要尽量明确。
     - 使用有意义的名称；使用结构化或者作用目标相关，而不是抽象的名称。
     - 全局通用命名时，需要加特定前缀如 `zk-wrap`
     - 局部命名时，可以根据模块内容或就近父节点为前缀

     2.编码风格

     - 缩进方式：使用 `4` 个空格做为一个缩进层级，不允许使用 `2` 个空格 或 `tab` 字符。

     - 空格

       - `选择器` 与 `{` 之间必须包含空格。
       - `属性名` 与之后的 `:` 之间不允许包含空格， `:` 与 `属性值` 之间必须包含空格。
       - `列表型属性值` 书写在单行时，`,` 后必须跟一个空格。

     - 选择器

       - 如无必要，不得为 `id`、`class` 选择器添加类型选择器进行限定。
       - 选择器的嵌套层级应不大于 `3` 级，位置靠后的限定条件应尽可能精确
       - `>`、`+`、`~` 选择器的两边各保留一个空格。

     - 属性

       - 属性定义必须另起一行。

       - 属性定义后必须以分号结尾。

       - 在可以使用缩写的情况下，尽量使用属性缩写。

       - 属性前缀，标准属性放在最后，按冒号对齐方便阅读，也便于在编辑器内进行多行编辑。

         ```
         .box {
         -webkit-box-sizing: border-box;
            -moz-box-sizing: border-box;
                 box-sizing: border-box;
         }
         ```

     - 属性书写顺序: 位置 > 盒模型 > 排版 > 外观 > 其它

       - Positioning 位置

         ```
         // 包括 float、display、overflow……
         position: absolute;
         top: 50px;
         left: 0;
         overflow-x: hidden;
         ```

       - Box model 盒模型

         ```
         border: 1px solid #000
         margin: 20px;
         padding: 15px;
         width: 240px;
         height: 160px;  
         ```

       - Typographic 排版

         ```
         font-size: 16px;
         line-height: 32px;
         text-align: left;
         word-wrap: break-word
         ```

       - Visual 外观

         ```
         background: #fff url(images/logo.png) no-repeat;
         color: #000;
         ```

     - 清除浮动
       当子内容 float 浮动后，父级标签一定要清除浮动，通过对伪类设置 `clear` 的方式进行 `clearfix`。尽量不使用增加空标签的方式。[[参看\]](http://cssmojo.com/latest_new_clearfix_so_far/)

       ```
       // css 
       .clearfix::after {
           clear: both;
           content: "";
           display: table; 
       }
       ```

     - 颜色

       - RGB颜色值必须使用十六进制记号形式 `#rrggbb`。不允许使用 `rgb()`。
       - 颜色值可以缩写时，必须使用缩写形式, `border-color: #ccc;`
       - 颜色值不要使用英文命名色值,如 `color:red`
       - 颜色值最好全部采用小写字符

     - 数值

       - 当数值为0时，可以省略单位， `padding: 0; margin: 0;`
       - 当数值为 0 - 1 之间的小数时，省略整数部分的 `0`,如 `opacity: .8;`

     - z-index 一般以 5或10 为一个步长（如50,60,70），方便以后增加或修改

     - !important' 尽量不使用 `!important` 声明。

     - 字体

       - `font-family` 属性中的字体族名称应使用字体的英文 `Family Name`，其中如有空格，须放置在引号中。

       - 所谓英文 Family Name，为字体文件的一个元数据，常见名称如下：

         | 字体            | 操作系统 | Family Name         |
         | --------------- | -------- | ------------------- |
         | 宋体 (中易宋体) | Windows  | SimSun              |
         | 黑体 (中易黑体) | Windows  | SimHei              |
         | 微软雅黑        | Windows  | Microsoft YaHei     |
         | 微软正黑        | Windows  | Microsoft JhengHei  |
         | 华文黑体        | Mac/iOS  | STHeiti             |
         | 冬青黑体        | Mac/iOS  | Hiragino Sans GB    |
         | 文泉驿正黑      | Linux    | WenQuanYi Zen Hei   |
         | 文泉驿微米黑    | Linux    | WenQuanYi Micro Hei |

         ```
         //css用法
         h1 {
             font-family: "Microsoft YaHei";
         }
         ```

     - 字号

       - 需要在 Windows 平台显示的中文内容，其字号应不小于 `12px`。

     - 字重

       - CSS 的字重分 100 – 900 共九档，但目前受字体本身质量和浏览器的限制，实际上支持 `400` 和 `700` 两档，分别等价于关键词 `normal` 和 `bold`

     - 行高

       - `line-height` 默认全局定义为 1.5 比较舒适，可根据实际情况调整

     - Hack 针对某个浏览器写的样式或某个浏览器BUG的样式，必须加上注释说明

       ```
       // css
       .clearfix{
           zoom:1; /* for IE6 IE7 */
       }
       ```

207. ##### 编码规范的作用是什么？

     编码是否规范，直接影响代码的可读性、可维护性、可交接性等。一份好的代码，可以做到：不管有多少人共同参与同一项目，都可以确保每一行代码都像是同一个人编写的。

208. ##### 什么是盒模型？

     盒模型（内容（content）,内边距（padding）,边框（border）,外边距（margin））

209. ##### CSS 的属性 box-sizing 有什么值？分别有什么作用？

     content-box：默认标准盒模型，总宽=width+padding+border+margin
     border-box：IE标准，怪异盒模型，总宽=width+margin
     inherit：从父元素继承box-sizing属性

210. ##### 什么时服务器端渲染（SSR)

     Vue.js时构建客户端应用程序的框架。默认情况下，可以在浏览器中输出Vue组件，进行生成DOM和操作DOM。然而，也可以将同一个组件渲染为服务器端的HTML字符串，将它们直接发送到服务器，最后静态标记“混合”为客户端上完全交互的应用程序。

     服务器渲染的Vue.js应用程序也可以被认为是“同构”或“通用”，因为应用程序的大部分代码都可以在服务器和客户端上运行

211. ##### 如何判断当前脚本运行在浏览器端还是node环境中？（阿里）

     this === window ? 'browser' : 'node';

     通过判断Clobal对象是否为window，如果不为window，当前脚本没有运行在浏览器中

212. ##### JavaScript中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？

     hasOwnProperty

     JavaScript中hasOwnProperty函数方法是返回一个布尔值，指出一个对象是否具有指定名称的属性。此方法无法检查该对象的原型链中是否具有该属性；该属性必须是对象本身的一个成员。

     使用方法：

     object.hasOwnProperty(proName)

     其中参数object是必选项。一个对象的实例。

     proName是必选项。一个属性名称的字符串值

     如果object具有指定名称的属性，那么JavaScript中hasOwnProperty函数方法返回true，反之则返回false。